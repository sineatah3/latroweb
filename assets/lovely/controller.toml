[manifest]
version = "1.0.0"
dump_lua = true
priority = 1

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "function Controller:init()"
position = "after"
payload = "self.dragSelectActive = {active = false, mode = nil}\n"
match_indent = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "function Controller:init()"
position = "after"
payload = "--Touch controller\nself.touch_control = {s_tap = {target = nil,handled = true}, l_press = {target = nil, handled = true}}"
match_indent = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "self.HID.mouse = HID_type == 'mouse'"
position = "after"
payload = "        if self.HID.touch ~= (HID_type == 'touch') then\n            self.HID.touch = HID_type == 'touch'\n            for k, v in pairs(G.I.CARDAREA) do\n                v:set_ranks()\n            end\n        end"
match_indent = false

[[patches]]
[patches.regex]
target = "engine/controller.lua"
pattern = "function Controller:update([\\s\\S]+?)^end"
position = "at"
payload = "--Called every game logic update frame\nfunction Controller:update(dt)\n\n    --parse all locks and set\n    self.locked = false\n    if G.screenwipe then self.locks.wipe = true else self.locks.wipe = false end\n\n    for k, v in pairs(self.locks) do\n        if v then self.locked = true end\n    end\n    \n    if self.locks.frame_set then \n        self.locks.frame_set = nil\n        self.overlay_timer = 0\n        G.E_MANAGER:add_event(Event({\n            trigger = 'after',\n            delay = 0.1,\n            timer = 'UPTIME',\n            blocking = false,\n            blockable = false,\n            no_delete = true,\n            func = (function()\n                self.locks.frame = nil\n                return true\n            end)\n        }))\n    end\n\n    self.overlay_timer = self.overlay_timer or 0\n    if G.OVERLAY_MENU then \n        self.overlay_timer = self.overlay_timer + dt\n    else\n        self.overlay_timer = 0\n    end\n\n    if self.overlay_timer > 1.5 then self.locks.frame = nil end\n\n    --Remove anything from the registry that is no longer in game\n    self:cull_registry()\n\n    --Calculate the axis update and set the HID flags if there is any axis input\n    self:set_HID_flags(self:update_axis(dt))\n\n    --Set the cursor to be visible only if we are using a mouse or an axis to control the cursor position\n    if self.HID.pointer and not (self.HID.mouse or self.HID.touch) and not self.interrupt.focus then \n        G.CURSOR.states.visible = true\n    else\n        G.CURSOR.states.visible = false\n    end\n\n    --For mouse input, reset any controller things and set the cursor to be where the mouse is\n    self:set_cursor_position()\n        \n    --Handle all the button updates and key updates, call the required functions\n    if not G.screenwipe then \n        --Key press and release handling\n        for k, v in pairs(self.pressed_keys) do\n            if v then self:key_press_update(k, dt) end\n        end\n        for k, v in pairs(self.held_keys) do\n            if v then self:key_hold_update(k, dt) end\n        end\n        for k, v in pairs(self.released_keys) do\n            if v then self:key_release_update(k, dt) end\n        end\n\n        --Button press and release handling\n        for k, v in pairs(self.pressed_buttons) do\n            if v then self:button_press_update(k, dt) end\n        end\n        for k, v in pairs(self.held_buttons) do\n            if v then self:button_hold_update(k, dt) end\n        end\n        for k, v in pairs(self.released_buttons) do\n            if v then self:button_release_update(k, dt) end\n        end\n    end\n\n    self.frame_buttonpress = false\n\n    --reset press and release lists\n    self.pressed_keys = EMPTY(self.pressed_keys)\n    self.released_keys = EMPTY(self.released_keys)\n    self.pressed_buttons= EMPTY(self.pressed_buttons)\n    self.released_buttons = EMPTY(self.released_buttons)\n\n\n    --If using controller, update context and snap tos\n    if self.HID.controller then \n        --If there is a node/position to snap to from the cursor context layer\n        if self.cursor_context.stack[self.cursor_context.layer] then \n            local _context = self.cursor_context.stack[self.cursor_context.layer]\n            self:snap_to{node = (_context.node and not _context.node.REMOVED and _context.node), T = _context.cursor_pos}\n            self.interrupt.stack = _context.interrupt\n            self.cursor_context.stack[self.cursor_context.layer] = nil\n        end\n        --If there is a card the was being dragged but no longer is, snap to it\n        if self.dragging.prev_target and not self.dragging.target and getmetatable(self.dragging.prev_target) == Card and not self.dragging.prev_target.REMOVED then\n            --Overly complicated coyote time focus, so the user can quickly select cards without things going wonky\n            if not self.COYOTE_FOCUS then \n                self:snap_to{node = self.dragging.prev_target}\n            else\n                self.COYOTE_FOCUS = nil\n            end\n        end\n        --If the cursor should snap to a location\n        if self.snap_cursor_to then \n            self.interrupt.focus = self.interrupt.stack\n            self.interrupt.stack = false\n            if self.snap_cursor_to.type == 'node' and not self.snap_cursor_to.node.REMOVED then \n                self.focused.prev_target = self.focused.target\n                self.focused.target = self.snap_cursor_to.node\n                self:update_cursor()\n            elseif self.snap_cursor_to.type == 'transform' then\n                self:update_cursor(self.snap_cursor_to.T)\n            end\n            if self.focused.prev_target ~= self.focused.target and self.focused.prev_target then self.focused.prev_target.states.focus.is = false end\n            self.snap_cursor_to = nil\n        end\n    end\n\n    --Reset all collision states, get every node that collides with the cursor, then update the focus and hover targets\n    self:get_cursor_collision(G.CURSOR.T)\n    self:update_focus()\n    self:set_cursor_hover()\n    if self.L_cursor_queue then \n        self:L_cursor_press(self.L_cursor_queue.x, self.L_cursor_queue.y)\n        self.L_cursor_queue = nil\n    end\n\n    self.finger_cursor = self.cursor_hover.target\n    self.dragging.prev_target = self.dragging.target\n    self.released_on.prev_target = self.released_on.target\n    self.clicked.prev_target = self.clicked.target\n    self.hovering.prev_target = self.hovering.target\n\n    --Cursor is currently down\n    if not self.cursor_down.handled then \n        --TOUCH\n        ----------------------------------\n        if self.HID.touch then\n            if self.cursor_hover.target and self.cursor_hover.target.states.hover.can then\n                self.finger_focus = self.cursor_hover.target\n            end\n            self.touch_control.clear_touch = true\n        --NON TOUCH\n        ----------------------------------\n        else\n\n        end\n        --BOTH\n        ----------------------------------\n        self.cursor_down.distance = 0\n        self.cursor_down.duration = 0\n        if self.cursor_down.target.states.drag.can then\n            self.cursor_down.target.states.drag.is = true\n            self.cursor_down.target:set_offset(self.cursor_down.T, 'Click')\n            self.dragging.target = self.cursor_down.target\n            self.dragging.handled = false\n        elseif #self.collision_list == 0 and G.SETTINGS.enable_drag_select then\n            self.dragSelectActive.active = true\n        end\n        self.cursor_down.handled = true\n    end\n\n    if not self.cursor_up.handled then \n        self.dragSelectActive.active = false\n        self.dragSelectActive.mode = nil\n\n        --First, stop dragging\n        if self.dragging.target then\n            self.dragging.target:stop_drag()\n            self.finger_cursor = self.dragging.target\n            self.dragging.target.states.drag.is = false\n            self.dragging.target = nil\n        end\n\n        --TOUCH\n        ----------------------------------\n        if self.HID.touch then\n            if self.cursor_down.target then\n                if self.cursor_down.distance < G.MIN_CLICK_DIST and self.cursor_down.duration < (0.2 * G.SPEEDFACTOR) then\n                    if self.cursor_down.target.states.click.can and not self.touch_control.l_press.target then\n                        self.touch_control.s_tap.target = self.cursor_down.target\n                        self.touch_control.s_tap.time = self.cursor_up.time - self.cursor_down.time\n                        self.touch_control.s_tap.handled = false\n                    end\n                --if not, was the Cursor dragging some other thing?\n                elseif self.dragging.prev_target then\n                    local releasable = nil\n                    for _, v in ipairs(self.collision_list) do\n                        if v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) then\n                            releasable = v\n                            break\n                        end\n                    end\n                    if releasable and releasable.states.release_on.can then\n                        self.released_on.target = releasable\n                        self.released_on.handled = false\n                    end\n                end\n            end\n        --NON TOUCH\n        ----------------------------------\n        else\n            if self.cursor_down.target then\n                if\n                    not self.cursor_down.target.click_timeout\n                    -- Not sure what the click_timeout is for, but we need to bypass it when were dragging something on desktop or it always block the\n                    -- release of the card unless we drag it so fast it's under the 0.3s click_timeout time.\n                    -- or self.dragging.prev_target\n                    or self.cursor_down.target.click_timeout*G.SPEEDFACTOR > self.cursor_up.time - self.cursor_down.time\n                then\n                    if Vector_Dist(self.cursor_down.T, self.cursor_up.T) < G.MIN_CLICK_DIST then\n                        if self.cursor_down.target.states.click.can then\n                            self.clicked.target = self.cursor_down.target\n                            self.clicked.time = self.cursor_up.time - self.cursor_down.time\n                            self.clicked.handled = false\n                        end\n                    end\n                end\n\n                --was the Cursor dragging some other thing?\n                if self.dragging.prev_target then\n                    local releasable = nil\n                    for _, v in ipairs(self.collision_list) do\n                        if v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) then\n                            releasable = v\n                            break\n                        end\n                    end\n                    if releasable and releasable.states.release_on.can then\n                        self.released_on.target = releasable\n                        self.released_on.handled = false\n                    end\n                end\n            end\n        end\n        --BOTH\n        ----------------------------------\n\n        --Was the Cursor release in the same location as the Cursor press and within Cursor timeout?\n        self.cursor_up.handled = true\n    end\n\n    --TOUCH\n    ----------------------------------\n    if self.HID.touch then\n\n        if self.finger_focus then\n            if self.is_cursor_down and self.finger_focus:can_long_press() and self.cursor_down.duration > (0.2 * G.SPEEDFACTOR) and not self.touch_control.l_press.target and not self.touch_control.l_pressed then\n                self.touch_control.l_press.target = self.finger_focus\n                self.touch_control.l_press.handled = false\n            end\n        end\n    --NON TOUCH\n    ----------------------------------\n    else\n        --Cursor is currently hovering over something\n        if self.cursor_hover.target and self.cursor_hover.target.states.hover.can then\n            self.hovering.target = self.cursor_hover.target\n            if self.hovering.prev_target and self.hovering.prev_target ~= self.hovering.target then self.hovering.prev_target.states.hover.is = false end\n            self.hovering.target.states.hover.is = true\n            self.hovering.target:set_offset(self.cursor_hover.T, 'Hover')\n        elseif self.cursor_hover.target == nil and self.hovering.target then\n            self.hovering.target.states.hover.is = false\n            self.hovering.target = nil\n        end\n    end\n    --BOTH\n    ----------------------------------\n\n\n    --------------------------------------------------------------------\n    -- Sending all input updates to the game objects\n    --------------------------------------------------------------------\n    --touch\n    if self.HID.touch then\n        if self.finger_focus and not self.finger_focus:can_long_press() then\n            if self.finger_focus ~= self.hovering.target and self.finger_focus:can_hover_on_drag() then\n                self.hovering.target = self.finger_focus\n                self.hovering.handled = false\n            end\n        end\n\n        if self.dragSelectActive.active then\n            local distance = math.huge;\n            local closest = nil;\n            for _, v in ipairs(self.collision_list) do\n                local cur_distance = Vector_Dist(self.cursor_hover.T, v.T)\n                if v.area ~= nil and v.area.config.type == 'hand' and v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) and cur_distance < distance then\n                    closest = v\n                    distance = cur_distance\n                end\n            end\n\n            if closest and\n                (not self.dragSelectActive.mode -- We accept all cards if no mode is set\n                or self.dragSelectActive.mode == 'select' and not closest.highlighted -- We only accept cards that are not already highlighted if we are in select mode\n                or self.dragSelectActive.mode == 'deselect' and closest.highlighted) -- We only accept cards that are already highlighted if we are in deselect mode\n            then\n                if closest.highlighted then\n                    closest.area:remove_from_highlighted(closest)\n                    self.dragSelectActive.mode = 'deselect'\n                else\n                    closest.area:add_to_highlighted(closest)\n                    self.dragSelectActive.mode = 'select'\n                end\n            end\n        end\n\n        if not self.touch_control.s_tap.handled then\n            if self.touch_control.s_tap.target.single_tap then\n                self.touch_control.s_tap.target:single_tap()\n                if self.finger_focus and not self.finger_focus:can_long_press() then\n                    self.hovering.target = self.touch_control.s_tap.target\n                    self.hovering.handled = false\n                end\n            else\n                self.touch_control.s_tap.target:click()\n            end\n            self.touch_control.s_tap.handled = true\n            self.touch_control.clear_touch = nil\n        end\n\n        if not self.touch_control.l_press.handled then\n            self.hovering.target = self.touch_control.l_press.target\n            self.hovering.handled = false\n            self.touch_control.l_pressed = self.finger_focus\n            self.touch_control.l_press.handled = true\n        end\n\n        if self.touch_control.clear_touch or not self.finger_focus then\n            self.touch_control.l_press.target = nil\n            self.touch_control.l_pressed = nil\n            self.touch_control.s_tap.target = nil\n            self.hovering.target = nil\n\n            self.hovering.handled = false\n            self.touch_control.clear_touch = nil\n        end\n\n        if self.touch_control.l_pressed then\n            self.hovering.target = self.finger_focus\n        end\n\n        --The object being dragged\n        if not self.dragging.handled and self.cursor_down.duration and (self.cursor_down.duration > (0.1 * G.SPEEDFACTOR)) then\n            create_drag_target_from_card(self.dragging.target)\n            self.dragging.handled = true\n        end\n        if self.dragging.target then\n            self.dragging.target:drag()\n            -- We added this part to hide the card action buttons when the user start dragging the cards, we check that the card has\n            -- been dragged away from the start of the drag by a certain amount to avoid having hiding the button when the user is\n            -- clicking on a card as that would cause the button to show up again on the next update.\n            -- Sometime the distance doesn't seem to trigger so we also check for the duration of the drag.\n            if self.dragging.target and self.dragging.target.highlighted and self.dragging.target.area\n                and self.dragging.target.area.config.type ~= 'hand' and self.cursor_down and self.cursor_up\n                and (Vector_Dist(self.cursor_down.T, self.cursor_up.T) > --[[ G.MIN_CLICK_DIST ]] 5 or (self.cursor_down.duration > (0.25 * G.SPEEDFACTOR)))\n            then\n                self.dragging.target.area:remove_from_highlighted(self.dragging.target)\n            end\n        end\n\n        --The object released on\n        if not self.released_on.handled and self.dragging.prev_target then\n            self.released_on.target:release(self.dragging.prev_target)\n            self.released_on.handled = true\n        end\n\n        if not self.hovering.handled then\n            if self.hovering.target then\n                self.hovering.target:hover()\n                self.hovering.target.states.hover.is = true\n                self.hovering.target:set_offset(self.cursor_hover.T, 'Hover')\n\n                if self.hovering.prev_target and self.hovering.prev_target ~= self.hovering.target then\n                    self.hovering.prev_target.states.hover.is = false\n                    self.hovering.prev_target:stop_hover()\n                end\n            elseif self.hovering.prev_target then\n                self.hovering.prev_target.states.hover.is = false\n                self.hovering.prev_target:stop_hover()\n            end\n            self.hovering.handled = true\n        end\n    else\n        --The clicked object\n        if not self.clicked.handled then\n            self.clicked.target:click()\n            self.clicked.handled = true\n        end\n        \n        if self.dragSelectActive.active then\n            local distance = math.huge;\n            local closest = nil;\n            for _, v in ipairs(self.collision_list) do\n                local cur_distance = Vector_Dist(self.cursor_hover.T, v.T)\n                if v.area ~= nil and v.area.config.type == 'hand' and v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) and cur_distance < distance then\n                    closest = v\n                    distance = cur_distance\n                end\n            end\n\n            if closest and\n                (not self.dragSelectActive.mode -- We accept all cards if no mode is set\n                or self.dragSelectActive.mode == 'select' and not closest.highlighted -- We only accept cards that are not already highlighted if we are in select mode\n                or self.dragSelectActive.mode == 'deselect' and closest.highlighted) -- We only accept cards that are already highlighted if we are in deselect mode\n            then\n                if closest.highlighted then\n                    closest.area:remove_from_highlighted(closest)\n                    self.dragSelectActive.mode = 'deselect'\n                else\n                    closest.area:add_to_highlighted(closest)\n                    self.dragSelectActive.mode = 'select'\n                end\n            end\n        end\n\n        --Process registry clicks\n        self:process_registry()\n\n        --The object being dragged\n        if not self.dragging.handled and self.cursor_down.duration and (self.cursor_down.duration > (0.15 * G.SPEEDFACTOR)) then\n            create_drag_target_from_card(self.dragging.target)\n            self.dragging.handled = true\n        end\n        if self.dragging.target then\n            -- We added this part to hide the card action buttons when the user start dragging the cards, we check that the card has\n            -- been dragged away from the start of the drag by a certain amount to avoid having hiding the button when the user is\n            -- clicking on a card as that would cause the button to show up again on the next update.\n            -- Sometime the distance doesn't seem to trigger so we also check for the duration of the drag.\n            if self.dragging.target and self.dragging.target.area and self.dragging.target.area.config.type ~= 'hand' and self.cursor_down and self.cursor_up and (Vector_Dist(self.cursor_down.T, self.cursor_up.T) > --[[ G.MIN_CLICK_DIST ]] 5 or (self.cursor_down.duration > (0.15 * G.SPEEDFACTOR))) then\n                self.dragging.target.area:remove_from_highlighted(self.dragging.target)\n            end\n            self.dragging.target:drag()\n        end\n\n        --The object released on\n        if not self.released_on.handled and self.dragging.prev_target then\n            if self.dragging.prev_target == self.hovering.target then self.hovering.target:stop_hover();self.hovering.target = nil end\n            self.released_on.target:release(self.dragging.prev_target)\n            self.released_on.handled = true\n        end\n\n        --The object being hovered over\n        if self.hovering.target then\n            self.hovering.target:set_offset(self.cursor_hover.T, 'Hover')\n            if self.hovering.prev_target ~= self.hovering.target then\n                if self.hovering.target ~= self.dragging.target then\n                    self.hovering.target:hover()\n                elseif self.HID.touch then\n                    local _ID =  self.hovering.target.ID\n                    G.E_MANAGER:add_event(Event({\n                        trigger = 'after',\n                        blockable = false,\n                        blocking = false,\n                        delay = G.MIN_HOVER_TIME,\n                        func = function()\n                                if (self.hovering.target and _ID == self.hovering.target.ID) then\n                                self.hovering.target:hover()\n                            end\n                        return true\n                        end\n                    }))\n                    if self.hovering.prev_target then\n                        self.hovering.prev_target:stop_hover()\n                    end\n                end\n                if self.hovering.prev_target then\n                    self.hovering.prev_target:stop_hover()\n                end\n            end\n        elseif self.hovering.prev_target then\n            self.hovering.prev_target:stop_hover()\n        end\n        if self.hovering.target and self.hovering.target == self.dragging.target then\n            self.hovering.target:stop_hover()\n        end\n    end\n\n    if self.is_cursor_down then\n        self.cursor_down.distance = math.max(Vector_Dist(self.cursor_down.T, self.cursor_hover.T), self.cursor_down.distance or 0)\n        self.cursor_down.duration = G.TIMERS.TOTAL - self.cursor_down.time -- self.cursor_down.duration = G.TIMERS.UPTIME - self.cursor_down.time\n        if self.cursor_up.target then\n            self.cursor_up.target = nil\n        end\n    end\n    if not self.is_cursor_down then\n        if self.cursor_down.target then\n            self.cursor_down.target = nil\n            self.cursor_down.distance = nil\n            self.cursor_down.duration = nil\n        end\n    end\nend\n"
times = 1

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "if v.states.hover.can and (not v.states.drag.is or self.HID.touch) then"
position = "at"
payload = "            if v.states.hover.can and (not v.states.drag.is) then"
match_indent = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "if not self.cursor_hover.target or (self.dragging.target and not self.HID.touch) then self.cursor_hover.target = G.ROOM end"
position = "at"
payload = "    if not self.cursor_hover.target or self.dragging.target then self.cursor_hover.target = G.ROOM end"
match_indent = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "local press_node =  (self.HID.touch and self.cursor_hover.target) or self.hovering.target or self.focused.target"
position = "at"
payload = "    local press_node =  (self.cursor_hover.target) or self.hovering.target or self.focused.target"
match_indent = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = "self.cursor_up.target = self.hovering.target or self.focused.target"
position = "at"
payload = "    self.cursor_up.target = self.hovering.target or self.focused.target or self.dragging.target"
match_indent = false